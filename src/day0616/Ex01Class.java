package day0616;

// Class
// Java 에서의 프로그램 하나하나를 뜻함.
// 지금까지 만든 프로그램은 3세대 객체지향적 언어의 관점에서는 클래스라고 부를 수 없었다.
// 그 이유는, 클래스는 반드시 데이터를 저장할 공간과 해당 클래스 변수들이
// 실행할 수 있는 기능이 같이 정의되어있어야 했지만
// 우리는 지금까지 둘 중 하나만 정의해왔기 때문이다.

// 프로그램을 기능의 집합이라고 생각했던 2세대 절차지향적 언어와 다르게
// 3세대 객체지향적 언어에서는 프로그램을 더 작은 프로그램 변수의 집합으로 본다.

// 즉 학생과 관련된 프로그램을 만들게 될때
// 학생과 관련한 클래스를 만들어서 그 안에
// 해당 클래스 변수, 즉
// 1. 어떠한 정보를 가질지
// 2. 그 객체들이 실행시킬 메소드를 정의하고,
// 필요할 때 마다 그 객체들을 만들어서 사용하게 된다.

// 클래스의 구성
// 필드 + 메소드

// 필드 : 해당 클래스의 객체들이 가지고 있을 데이터들의 종류
// 메소드 : 해당 클래스의 객체들이 실행가능한 기능들

// static 키워드는 객체지향적 프로그래밍에서는 사용을 기피해야하는 키워드이다.
// 그 이유는, static 키워드가 붙으면 해당 메소드를
// 객체를 따로 생성하지 않고 메소드만 불러와서 사용을 하겠다는 의마가 되기 때문에
// 반드시 객체 생성을 거쳐야 하는 객체지향적 관점에서는 static 키워드는 사용을 피해야한다.

// 객체 vs 인스턴스
// 객체 : 클래스 타입의 변수
// 인스턴스 : 실체화가 끝난 클래스 타입의 변수

public class Ex01Class {
    // 클래스 안에 필드는
    // 우리가 전에 만들었떤 구조체와 똑같은 방식으로 선언한다.
    // 즉, 해당 클래스 변수들이 어떤 데이터를 저장 가능한지를
    // 우리가 "선언"만 해주고, 실제 해당데이터를 저장하는 것은
    // 그 객체를 사용하는 곳에서 해주면 된다.

    // 클래스 안에 메소드는
    // 해당 클래스 변수를 만들고 나서
    // 그 객체들이 공통적으로 실행시킬 수 있도록 만들어 주되
    // 앞서 설명했듯이 더이상 static 키워드는 붙지 않는다.

    // 생성자(Constructor)
    // 생성자란, 생체를 생성할 때 실행시킬 코드를 모아둔
    // 메소드이다.
    // 우리가 특별히 생성자를 따로 정의하지 않더라도
    // Java가 기본적으로 제공해주는 기본 생성자가
    // 해당 객체의 필드를 초기화 시켜주는 역할을 한다.
    // 단, 이 때에는 기본형 데이터타입의 필드는 0으로,
    // 참조형 데이터타입의 필드는 null로 초기화해준다.

    // 생성자는 특이하게 리턴 타입이 아예 없고, 메소드 이름은
    // 반드시 클래스 이름과 일치해야한다.

    // 필요에 따라서는 우리가 직접 생성자를 정의해 줄수도 있는데
    // 이때에는 한가지 주의할 점이
    // 파라미터 있는 생성자만 만들어주면, 더이상 파라미터 없는 생성자는
    // 사용할 수 없다. 예시 - > Scanner

    // 오버라이드(Override)
    // 오버라이드란, 부모 클래스로부터 상속받은 메소드를
    // 자식 클래스가 재정의하는 것을 오버라이드라고 한다.
    // 단, 오버라이드를 할 때 한가지 주의할 점은
    // 해당 메소드를 선언할 때, 반드시
    // 부모 클래스가 적은 것을 똑같이 적어야 한다라는 점이다.

    // 호출 순위
    // 똑같은 개념끼리는 같은 이름을 사용 할 수 없지만
    // 필드와 메소드 변수는 서로 다른 개념이기 때문에
    // 같은 이름을 사용 할 수 있는 대신
    // 해당 메소드에서는 똑같은 이름이면 무조건
    // 변수를 뜻하게 된다.
    // 만약 필드와 메소드 변수가 같은 이름을 가졌을 때
    // 해당 변수에서 필드를 호출할 때에는
    // "이 메소드를 실행하는 객체" 라는 뜻을 가진
    // this라는 키워드를 사용하게 된다.
    // 즉, 우리가 어떠한 파라미터로 값을 받아 올 때
    // 필드와 파라미터의 이름이 같을 경우
    // "이 메소드를 실행시키는 객체"의 필드에 파라미터의 현재 값을 저장해라
    // 를 적기위해서는
    // this.필드 = 파라미터로 적어야 한다.

    // 접근제한자(Access Modifier)
    // 접근제한자란! 필드 혹은 메소드를
    // 외부 클래스가 접근을 할수 있을지 말지를 지정하는 키워드이다.
    // public : 퍼블릭 접근제한자는 해당 메소드 / 필드를 다른 패키지의
    // 다른 클래스도 접근할 수 있게 한다.
    // protected : 프로텍티드 접근제한자는 같은 패키지의 다른 클래스는
    // 접근 가능하지만 외부 패키지의 다른 클래스는 상속관계가 아니면 접근할 수 없다.
    // default : 디폴트 접근제한자는 같은 패키지의 다른 클래스들만 접근 가능하다.
    // 하지만 이미 default라는 키워드는 switch문에서 사용하기 때문에
    // 우리가 아무런 접근 제한자를 적어주지 않으면 자동으로 디폴트 접근 제한자가 걸린다.
    // 또한, 같은 패키지만 접근 가능이기 때문에 "패키지 접근제한자"
    // 라고도 부르긴 하지만 package라는 키워드도 이미 사용중이므로 우리가 직접 쓰진 못한다.
    // private : 프라이빗 접근제한자는 해당 클래스 내부에서만 사용한다라는 의미로써
    // 다른 클래스면 같은 패키지이건 다른 패키지이건 접근할 수 없다.

    // 데이터 은닉화 (캡슐화)
    // 데이터 은닉화란 기본적으로 우리가 만드는 클래스의 객체
    // 안의 세부 내용을 외부에게 알리지 않고 다 숨기겠다 라는 의미이다.
    // 즉, 외부가 반드시 사용해야할 메소드 외에는 전부다 직접적인 접근을 막는 것이다.
    // 이렇게 직접 적인 접근을 막고, 꼭 알아야할 메소드만 공개하는 것을
    // 우리가 캡슐화라고 한다.
    // 캡슐화의 가장 핵심은 접근을 막는 것이므로 당연히 우리가
    // 기존에서는 public 접근제한자만 사용했지만.
    // 이제는 무조건 private 접근제한자를 사용하되
    // 외부가 사용해야할 메소드만 public 접근 제한자를 적용하면 된다.

    // getter / setter
    // 갯터 / 셋터는 객체의 필드를 캡슐화하는 방법으로써,
    // 우리가 앞으로는 모든 필드에 private 접근 제한자를 적용시키면
    // 더이상 외부 클래스가 직접적으로 해당 필드에 값을 저장하거나
    // 아니면 저장된 값을 호출할 수 없게 된다.
    // 대신, 겟터 / 셋터 라는 메소드를 통해서 값을 저장하거나
    // 저장된 값을 호출하게 된다.

    // 겟터 : 겟터는 필드의 현재 저장된 값을 불러오는 메소드이다.
    // 켓터는 다은과 같은 형식을 가진다.
    // public 필드타입 get필드이름(){
    //      return 필드이름;
    // }

    // 셋터 : 셋터는 해당 필드의 외부의 값을 저장하는 메소드이다.
    // 셋터는 다음과 같은 형식을 가진다.
    // public void set필드이름(필드와 동일한 파라미터){
    //      this.필드 = 파라미터;
    // }


}
